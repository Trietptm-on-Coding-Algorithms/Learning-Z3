from z3 import *

def display_model(m):
    block = {}
    for x in m:
        if "b" in str(x):
            block[ord(str(x)[-1:])] = int(str(m[x]))

    password = "".join(map(chr, block.values()))
    print(password)

def get_models(F):
    s = Solver()
    s.add(F)
    while True:
        if s.check() == sat:
            m = s.model()
            display_model(m)
            block = []
            for d in m:
                if d.arity() > 0:
                    raise Z3Exception("uninterpreted functions are not supported")
                c = d()
                if is_array(c) or c.sort().kind() == Z3_UNINTERPRETED_SORT:
                    raise Z3Exception("arrays and uninterpreted sorts are not supported")
                block.append(c != m[d])
            s.add(Or(block))
        else:
            print("done")
            break

def calculate(password):
    rax, rbx, rcx, rsi, rbp, r8, r9, r10, r11, r12, r13, r14, r15 = BitVecs("rax rbx rcx rsi rbp r8 r9 r10 r11 r12 r13 r14 r15", 64)

    i = BitVec("i", 8)

    rcx = 0x555555

    for i in range(len(password)):
        r13 = 0x2EFA16D0D7B56313
        r12 = 0x0D105E92F284A9CED
        rbp = 0x0C2FDC6E7E84BDF1B
        r9 = 0x0F1B06F67F7109574
        r8 = 0x9CBCAF82CBBB622E
        rbx = 0x80238EB2DA65B738
        rsi = 0x8BCDCD41F52A3FD
        r11 = 0x0F743232BE0AD5C03
        r10 = 0x37D59EC93CC6D155

        rdx = password[i]
        rax = rdx
        r14 = rcx
        rdx = (rdx + rdx)
        r15 = r8
        r14 = (~r14)
        r14 = (r14 + r14)
        rdx = rdx & r14
        rcx = (rcx + rdx)
        rdx = rax
        rcx = (rcx * r13)
        rdx = (rdx * r12)
        rdx = (rdx + rcx)
        rdx = (rdx * rbp)
        r14 = rdx
        rdx = rdx | r9
        r14 = r14 & r9
        rcx = rdx
        rax = r14
        rcx = (rcx - r14)
        rax = (rax - rdx)
        rcx = (rcx + rcx)
        rax = (rax + rax)
        rcx = rcx & r8
        r15 = (r15 - rax)
        rax = r15
        r15 = rcx
        r15 = (-r15)
        rax = (rax + r15 * 2)
        r14 = (r14 * r11)
        rax = rax & rbx
        rax = (rax + rcx)
        rcx = 0x718FE0E52CEF734C
        rdx = (rdx * rsi)
        rax = (rax * rsi)
        rdx = (rdx + r14)
        rax = (rax - rdx)
        rdx = 0x75D7C82EBB4962B9
        rax = (rax * r10)
        rax = (rax + rcx)
        rcx = rax
        rax = LShR(rax, 0x19)
        r14 = rax
        rcx = (rcx << 0x07)
        r14 = (~r14)
        r14 = r14 | rdx
        r15 = (rax + r14 + 1)
        r14 = r15
        r15 = r15 & rcx
        r14 = r14 ^ rcx
        r14 = (r14 + r15)
        rax = rax | rdx
        rax = (rax - rdx )
        rdx = rax
        rax = rcx
        rax = (~rax)
        rax = rax & rdx
        rax = (rax + rcx)
        rcx = r14
        rcx = rcx ^ rax
        rax = rax & r14
        rcx = (rcx + rax)
    return rcx

def is_alphanum(x):
    return Or(And(x >= 0x41, x <= 0x5a), And(x >= 0x61, x <= 0x7a), And(x >= 0x30, x <= 0x39))

if __name__ == "__main__":
    F = []
    length = 10
    checksum = BitVec("checksum", 64)
    password = [BitVec("b%d" % i, 64) for i in range(length)]

    F.extend([is_alphanum(password[i]) for i in range(length)])

    F.extend([
        checksum == 9211484110692677630,
        calculate(password) == checksum
    ])

    get_models(F)