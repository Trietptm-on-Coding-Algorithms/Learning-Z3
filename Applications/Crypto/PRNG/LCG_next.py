# Predict the next and previous number generated by LCG
#
# Use: 
#    python LCG_next.py 
# 
from z3 import *

solver = Solver()

# Most of the time, people recommended to use cryptographically secure random 
# for using in any cryptographic activity. What if we don't?

# Linear Congruential Generator (https://en.wikipedia.org/wiki/Linear_programming)
# is an algorithm that yields a sequence of pseudo randomized numbers calculated 
# with a discontinuous piecewise linear equation.

# Generator is defined by the recurrence relation of:
#    X[n+1] = (a * X[n] + c) mod m

# 12 states as sources of analysis
output_prev = BitVec('output_prev', 32)
state1 = BitVec('state1', 32)
state2 = BitVec('state2', 32)
state3 = BitVec('state3', 32)
state4 = BitVec('state4', 32)
state5 = BitVec('state5', 32)
state6 = BitVec('state6', 32)
state7 = BitVec('state7', 32)
state8 = BitVec('state8', 32)
state9 = BitVec('state9', 32)
state10 = BitVec('state10', 32)
output_next = BitVec('output_next', 32)

# Randomize with a = 214013 and c = 2531011
# Give the relationship as constraints
solver.add(state2 == state1*214013+2531011)
solver.add(state3 == state2*214013+2531011)
solver.add(state4 == state3*214013+2531011)
solver.add(state5 == state4*214013+2531011)
solver.add(state6 == state5*214013+2531011)
solver.add(state7 == state6*214013+2531011)
solver.add(state8 == state7*214013+2531011)
solver.add(state9 == state8*214013+2531011)
solver.add(state10 == state9*214013+2531011)

solver.add(output_prev==URem((state1>>16)&0x7FFF,100))
solver.add(URem((state2>>16)&0x7FFF,100)==29)
solver.add(URem((state3>>16)&0x7FFF,100)==74)
solver.add(URem((state4>>16)&0x7FFF,100)==95)
solver.add(URem((state5>>16)&0x7FFF,100)==98)
solver.add(URem((state6>>16)&0x7FFF,100)==40)
solver.add(URem((state7>>16)&0x7FFF,100)==23)
solver.add(URem((state8>>16)&0x7FFF,100)==58)
solver.add(URem((state9>>16)&0x7FFF,100)==61)
solver.add(output_next==URem((state10>>16)&0x7FFF,100))

print(solver.check())
print(solver.model())